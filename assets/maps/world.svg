import React, {
  useState,
  useCallback,
  useMemo,
  forwardRef,
  useImperativeHandle,
  useRef,
  useEffect,
} from "react";
import {
  View,
  StyleSheet,
  Dimensions,
  ActivityIndicator,
  TouchableOpacity,
  Text,
  Platform,
} from "react-native";
import Svg, { Path, G } from "react-native-svg";
import {
  Gesture,
  GestureDetector,
  GestureHandlerRootView,
} from "react-native-gesture-handler";
import Animated, {
  useSharedValue,
  useAnimatedStyle, // Nadal potrzebne dla Animated.View, jeśli jakieś są
  useAnimatedProps, // Kluczowe dla animowania atrybutów SVG
  withTiming,
  runOnJS,
} from "react-native-reanimated";
import ViewShot from "react-native-view-shot";
import * as Sharing from "expo-sharing";
// Poprawiony import dla FileSystem, aby uniknąć błędu TS1005
import * as ExpoFileSystem from "expo-file-system";
import { FontAwesome } from "@expo/vector-icons";

// Użyj zaimportowanego modułu ExpoFileSystem
const FileSystem = Platform.OS === "web" ? null : ExpoFileSystem;

// Załóżmy, że worldGeoData jest obiektem JS/JSON po przetworzeniu
// np. przez skrypt z folderu /scripts
import worldGeoData from "../assets/maps/world.svg";

// Definicje typów dla danych SVG
interface SvgPathItem {
  id: string; // Kluczowe dla logiki aplikacji
  d: string;
  name?: string;
  class?: string;
  [key: string]: any; // Pozwala na inne atrybuty
}

interface SvgGroupItem {
  id?: string;
  paths: SvgPathItem[];
  [key: string]: any;
}

interface SvgData {
  viewBox: string; // Oczekujemy camelCase, np. "0 0 2000 857"
  paths: SvgPathItem[];
  groups: SvgGroupItem[];
  width?: string | number;
  height?: string | number;
}

const AnimatedG = Animated.createAnimatedComponent(G);

const { width: screenWidth, height: screenHeight } = Dimensions.get("window");

interface CountryPathProps {
  pathData: string;
  countryCode: string;
  // isSelected: boolean; // Nie jest już bezpośrednio używane tutaj
  onPress: (code: string) => void;
  fillColor: string;
  strokeColor: string;
  strokeWidth: number;
}

const CountryPath = React.memo(
  ({
    pathData,
    countryCode,
    onPress,
    fillColor,
    strokeColor,
    strokeWidth,
  }: CountryPathProps) => {
    const handlePress = useCallback(() => {
      onPress(countryCode);
    }, [onPress, countryCode]);

    return (
      <Path
        d={pathData}
        fill={fillColor}
        stroke={strokeColor}
        strokeWidth={strokeWidth}
        onPress={handlePress}
      />
    );
  }
);

interface InteractiveMapProps {
  selectedCountries: string[];
  totalCountries: number;
  onCountryPress: (countryCode: string) => void;
  style?: object;
  themeColors: {
    selected: string;
    default: string;
    background: string;
    stroke: string;
    highlight: string;
  };
}

export interface InteractiveMapRef {
  resetMap: () => void;
  captureAndShareScreenshot: () => Promise<void>;
}

// Domyślne dane SVG na wypadek, gdyby ładowanie zawiodło lub dane były niekompletne
const defaultSvgData: SvgData = {
  viewBox: "0 0 1000 500", // Domyślny viewBox
  paths: [],
  groups: [],
};

const InteractiveMap = forwardRef<InteractiveMapRef, InteractiveMapProps>(
  (
    { selectedCountries, totalCountries, onCountryPress, style, themeColors },
    ref
  ) => {
    const [parsedMapData, setParsedMapData] = useState<SvgData | null>(
      null
    );
    const [isLoading, setIsLoading] = useState(true);
    const [isScreenshotting, setIsScreenshotting] = useState(false);

    const scale = useSharedValue(1);
    const translateX = useSharedValue(0);
    const translateY = useSharedValue(0);
    const savedScale = useSharedValue(1);
    const savedTranslateX = useSharedValue(0);
    const savedTranslateY = useSharedValue(0);

    const viewShotRef = useRef<ViewShot>(null);

    useEffect(() => {
      // Zakładamy, że worldGeoData jest już obiektem typu SvgData
      // Jeśli worldGeoData jest komponentem React (np. z react-native-svg-transformer),
      // ta logika musi zostać zmieniona, aby wyciągnąć dane z propsów komponentu
      // lub plik SVG musi być przetworzony na JSON/JS object.
      if (
        worldGeoData &&
        typeof worldGeoData === "object" &&
        (worldGeoData as SvgData).viewBox // Sprawdzamy, czy kluczowe pole istnieje
      ) {
        setParsedMapData(worldGeoData as SvgData);
      } else {
        console.error(
          "Map data is not in the expected SvgData object format or is missing. Check import and structure of worldGeoData.",
          worldGeoData
        );
        // Można ustawić parsedMapData na defaultSvgData lub stan błędu
        // setParsedMapData(defaultSvgData); // Aby uniknąć crashu, ale mapa będzie pusta/domyślna
      }
      setIsLoading(false);
    }, []);

    // Użyj parsedMapData lub defaultSvgData, aby uniknąć błędów z null/undefined
    const currentMapData = parsedMapData || defaultSvgData;
    const {
      viewBox, // Już nie potrzebuje domyślnej wartości tutaj
      paths: mapPaths,
      groups: mapGroups,
    } = currentMapData;

    const [vbX, vbY, vbWidth, vbHeight] = viewBox // viewBox z currentMapData
      .split(" ")
      .map(Number);

    const aspectRatio = vbWidth && vbHeight ? vbWidth / vbHeight : 2;

    const mapLayout = useMemo(() => {
      const containerWidth = screenWidth;
      const containerHeight = screenHeight * 0.75;
      let mapDisplayWidth = containerWidth;
      let mapDisplayHeight = containerWidth / aspectRatio;

      if (mapDisplayHeight > containerHeight) {
        mapDisplayHeight = containerHeight;
        mapDisplayWidth = containerHeight * aspectRatio;
      }
      return {
        width: mapDisplayWidth,
        height: mapDisplayHeight,
        offsetX: (containerWidth - mapDisplayWidth) / 2,
        offsetY: (containerHeight - mapDisplayHeight) / 2,
      };
    }, [aspectRatio, screenWidth, screenHeight]);

    const resetMapAnimation = useCallback(() => {
      "worklet";
      scale.value = withTiming(1);
      translateX.value = withTiming(0);
      translateY.value = withTiming(0);
      savedScale.value = 1;
      savedTranslateX.value = 0;
      savedTranslateY.value = 0;
    }, [scale, translateX, translateY, savedScale, savedTranslateX, savedTranslateY]);

    const captureAndShare = async () => {
      if (!viewShotRef.current || !FileSystem) {
        console.error(
          "ViewShot ref or FileSystem (ExpoFileSystem) not available."
        );
        runOnJS(setIsScreenshotting)(false); // Upewnij się, że resetujesz stan
        return;
      }
      runOnJS(setIsScreenshotting)(true);

      await new Promise((resolve) => setTimeout(resolve, 150));

      try {
        const uri = await viewShotRef.current.capture?.();
        if (!uri) {
          console.error("Failed to capture screenshot: URI is undefined");
          runOnJS(setIsScreenshotting)(false);
          return;
        }

        if (Platform.OS !== "web" && FileSystem.cacheDirectory) {
          const localUri = `${FileSystem.cacheDirectory}map_screenshot.png`;
          await FileSystem.copyAsync({ from: uri, to: localUri });
          await Sharing.shareAsync(localUri, {
            mimeType: "image/png",
            dialogTitle: "Share your map progress!",
          });
        } else if (Platform.OS === "web") {
          alert(
            "Screenshot captured (web): " +
              uri +
              "\nSharing needs custom web implementation."
          );
        }
      } catch (error) {
        console.error("Error capturing or sharing screenshot:", error);
      } finally {
        runOnJS(setIsScreenshotting)(false);
      }
    };

    useImperativeHandle(ref, () => ({
      resetMap: resetMapAnimation,
      captureAndShareScreenshot: captureAndShare,
    }));

    const pinchGesture = Gesture.Pinch()
      .onUpdate((event) => {
        scale.value = savedScale.value * event.scale;
      })
      .onEnd(() => {
        savedScale.value = scale.value;
        if (scale.value < 0.8) {
          scale.value = withTiming(0.8);
          savedScale.value = 0.8;
        } else if (scale.value > 7) {
          scale.value = withTiming(7);
          savedScale.value = 7;
        }
      });

    const panGesture = Gesture.Pan()
      .onUpdate((event) => {
        translateX.value = savedTranslateX.value + event.translationX;
        translateY.value = savedTranslateY.value + event.translationY;
      })
      .onEnd(() => {
        savedTranslateX.value = translateX.value;
        savedTranslateY.value = translateY.value;
        const limitX =
          (mapLayout.width * scale.value - mapLayout.width) / 2 +
          mapLayout.width * 0.2;
        const limitY =
          (mapLayout.height * scale.value - mapLayout.height) / 2 +
          mapLayout.height * 0.2;

        translateX.value = withTiming(
          Math.max(-limitX, Math.min(limitX, translateX.value))
        );
        translateY.value = withTiming(
          Math.max(-limitY, Math.min(limitY, translateY.value))
        );
        savedTranslateX.value = translateX.value;
        savedTranslateY.value = translateY.value;
      });

    const composedGesture = Gesture.Simultaneous(pinchGesture, panGesture);

    // Zamiast animatedMapStyle, użyj useAnimatedProps dla AnimatedG
    const animatedGProps = useAnimatedProps(() => {
      return {
        transform: [ // Reanimated może tłumaczyć to na odpowiednie atrybuty SVG
          { translateX: translateX.value },
          { translateY: translateY.value },
          { scale: scale.value },
        ],
        // Alternatywnie, można ustawić indywidualne atrybuty, jeśli powyższe nie działa zgodnie z oczekiwaniami:
        // translateX: translateX.value,
        // translateY: translateY.value,
        // scale: scale.value,
      };
    });


    const renderSvgPaths = useCallback(
      (paths: SvgPathItem[], groups: SvgGroupItem[]) => {
        const elements: JSX.Element[] = [];
        for (const group of groups) {
          if (group.paths && Array.isArray(group.paths)) {
            for (const pathItem of group.paths) {
              if (pathItem && pathItem.d && pathItem.id) {
                const countryCode = pathItem.id;
                const isSelected = selectedCountries.includes(countryCode);
                elements.push(
                  <CountryPath
                    key={`path-${countryCode}-${group.id || "group"}`}
                    pathData={pathItem.d}
                    countryCode={countryCode}
                    onPress={onCountryPress}
                    fillColor={
                      isSelected
                        ? themeColors.selected
                        : themeColors.default
                    }
                    strokeColor={themeColors.stroke}
                    strokeWidth={0.5}
                  />
                );
              }
            }
          }
        }
        for (const pathItem of paths) {
          if (pathItem && pathItem.d && pathItem.id) {
            const countryCode = pathItem.id;
            const isSelected = selectedCountries.includes(countryCode);
            elements.push(
              <CountryPath
                key={`path-${countryCode}-single`}
                pathData={pathItem.d}
                countryCode={countryCode}
                onPress={onCountryPress}
                fillColor={
                  isSelected ? themeColors.selected : themeColors.default
                }
                strokeColor={themeColors.stroke}
                strokeWidth={0.5}
              />
            );
          }
        }
        return elements;
      },
      [selectedCountries, onCountryPress, themeColors]
    );

    if (isLoading || !parsedMapData) { // Sprawdzaj parsedMapData, a nie currentMapData
      return (
        <View style={styles.centered}>
          <ActivityIndicator size="large" color={themeColors.highlight} />
        </View>
      );
    }

    const svgContentForDisplay = useMemo(
      () => renderSvgPaths(mapPaths, mapGroups),
      [renderSvgPaths, mapPaths, mapGroups] // mapPaths i mapGroups pochodzą z currentMapData
    );

    return (
      <View style={[styles.container, style, { height: mapLayout.height }]}>
        <GestureHandlerRootView style={styles.flexOne}>
          <GestureDetector gesture={composedGesture}>
            <Animated.View // Użyj Animated.View jako kontenera dla Svg, jeśli transformacje na G nie działają idealnie
              style={[
                styles.mapViewContainer, // Nowy styl dla kontenera Animated.View
                { width: mapLayout.width, height: mapLayout.height },
                // Jeśli transformacje mają być na tym kontenerze:
                // useAnimatedStyle(() => ({
                //   transform: [
                //     { translateX: translateX.value },
                //     { translateY: translateY.value },
                //     { scale: scale.value },
                //   ],
                // })),
              ]}
            >
              <Svg
                width="100%"
                height="100%"
                viewBox={viewBox} // z currentMapData
                preserveAspectRatio="xMidYMid meet"
              >
                {/* Poprawka dla błędu TS2322: użyj animatedProps zamiast style */}
                <AnimatedG animatedProps={animatedGProps}>
                  {svgContentForDisplay}
                </AnimatedG>
              </Svg>
            </Animated.View>
          </GestureDetector>
        </GestureHandlerRootView>

        {isScreenshotting && FileSystem && (
          <ViewShot
            ref={viewShotRef}
            options={{
              fileName: "map_progress",
              format: "png",
              quality: 1.0,
              width: 2000,
              height: Math.round(2000 / aspectRatio),
            }}
            style={styles.hiddenViewShot}
          >
            <Svg
              width={2000}
              height={Math.round(2000 / aspectRatio)}
              viewBox={viewBox} // z currentMapData
              preserveAspectRatio="xMidYMid meet"
            >
              <G>
                {renderSvgPaths(mapPaths, mapGroups)}
              </G>
            </Svg>
          </ViewShot>
        )}

        <View style={styles.controlsContainer}>
          <TouchableOpacity
            style={styles.controlButton}
            onPress={resetMapAnimation}
          >
            <FontAwesome name="arrows-alt" size={20} color={themeColors.stroke} />
          </TouchableOpacity>
          {FileSystem && (
            <TouchableOpacity
              style={styles.controlButton}
              onPress={captureAndShare}
            >
              <FontAwesome name="camera" size={20} color={themeColors.stroke} />
            </TouchableOpacity>
          )}
        </View>

        <View style={styles.statsContainer}>
          <Text style={[styles.statsText, { color: themeColors.stroke }]}>
            Visited: {selectedCountries.length} / {totalCountries}
          </Text>
        </View>
      </View>
    );
  }
);

const styles = StyleSheet.create({
  flexOne: { flex: 1 },
  container: {
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
    width: "100%",
  },
  mapViewContainer: { // Dodany styl dla kontenera Animated.View
    overflow: "hidden",
  },
  // mapView usunięty, Svg zajmuje 100% kontenera mapViewContainer
  centered: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  controlsContainer: {
    position: "absolute",
    bottom: 10,
    right: 10,
    flexDirection: "column",
    backgroundColor: "rgba(255,255,255,0.7)",
    borderRadius: 5,
    padding: 5,
    zIndex: 10,
  },
  controlButton: {
    padding: 8,
    marginVertical: 4,
    alignItems: "center",
  },
  statsContainer: {
    position: "absolute",
    top: 10,
    left: 10,
    backgroundColor: "rgba(0,0,0,0.5)",
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 5,
    zIndex: 10,
  },
  statsText: {
    fontSize: 14,
    fontWeight: "bold",
  },
  hiddenViewShot: {
    position: "absolute",
    left: -5000,
    top: -5000,
    backgroundColor: "white",
  },
});

export default InteractiveMap;
